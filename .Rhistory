require(leaps)
help(regsubsets)
extractp <- function(pred, fit) {
predClasses = attr(fit$terms, "dataClasses")
fact = predClasses[names(predClasses) == pred]
if(fact == "factor") {
pvals <- anova(fit)[,5]
pred.list <- rownames(anova(fit))
index <- which(pred.list == pred)
return(pvals[index])
}else {
pvals <- summary(fit)$coefficients[,4]
return(pvals[names(pvals)==pred])
}
}
require(DAAG)
attach(ais)
resp = "rcc"
fm = lm9rcc~., data=ais)
fm = lm(rcc~., data=ais)
extractp("wt", fm)
class(extractp("wt", fm))
a = extractp("wt", fm)
a
a[1]
a[1][1]
a[2]
fMaker <- function(pred, fitCurrent, add=T) {
add.new <- as.formula(paste(".~.+", pred))
rem.new <- as.formula(paste(".~.-", pred))
if(add) {
return(update(fitCurrent, add.new))
}  else {
return(update(fitCurrent, rem.new))
}
}
f <- fMaker("wt", fm, add=F)
f
class(fm)
stepfwd <- function(fitCurrent, fullmodel, aEnter = 0.1) {
predsIncluded <- rownames(anova(fitCurrent))
predsExcluded <- rownames(anova(fullmodel))
predsExcluded <- setdiff(predsExcluded, predsIncluded)
pvals <- sapply(predsExcluded, function(x) as.numeric(extractp(x, fMaker(x, fitCurrent))))
pvals <- unlist(pvals)
toAdd <- pvals[which(pvals==min(pvals))]
if(length(toAdd)==0) return(fitCurrent)
if(toAdd <= aEnter) return(fMaker(names(toAdd), fitCurrent))
return(fitCurrent)
}
fm
fc = lm(rcc~ht+wt)
stepfwd(fc,fm)
s <- stepfwd(fc,fm)
class(s)
#' Easily access p-values from linear models
#'
#' This function gives the user easy access to p-values for specific predictors from a linear model
#'
#' @param pred the predictor from the linear model whose p-value is desired
#' @param fit a linear model of type "lm"
#' @return the p-value for the desired predictor from the linear model
#' @author Cory Langille <lang1729@gmail.com>
#' @seealso \code{lm}
#' @export
#'
extractp <- function(pred, fit) {
predClasses = attr(fit$terms, "dataClasses")        #finds the predictors that are categorical variables
fact = predClasses[names(predClasses) == pred]
if(fact == "factor") {
pvalues <- anova(fit)[,5]
predList <- rownames(anova(fit))
index <- which(predList == pred)
return(pvalues[index])
}else {
pvalues <- summary(fit)$coefficients[,4]
return(pvalues[names(pvalues)==pred])
}
}
#' Create formulas from strings to be used in linear models
#'
#' This function take a string and a linear model and either adds the predictor to the model, or removes it.
#'
#' @param pred the predictor to be added or removed from the current model
#' @param fitCurrent the current model to be updated
#' @param add by default adds the predictor to to the model.  add=F removes the predictor from the model
#' @return the updated model of type "lm"
#'
fMaker <- function(pred, fitCurrent, add=T) {
addNew <- as.formula(paste(".~.+", pred))
remNew <- as.formula(paste(".~.-", pred))
if(add) {
return(update(fitCurrent, addNew))
}  else {
return(update(fitCurrent, remNew))
}
}
#' Adds a single predictor to a linear model based on its p-value
#'
#' This function will try and add a new predictor to a current model.  A predictor will be added if it has minimum p-value among all predictors and its p-value is below a certain threshold
#'
#' @param fitCurrent the current model of type "lm"
#' @param fullmodel a linear model containing all possible predictors.  Typically of the form lm(y~., data=data)
#' @param aEnter the threshold for adding the predictor, set to 0.1 be default
#' @return an updated linear model of type "lm"
#'
stepfwd <- function(fitCurrent, fullmodel, aEnter = 0.1) {
predsIncluded <- rownames(anova(fitCurrent))
predsExcluded <- rownames(anova(fullmodel))
predsExcluded <- setdiff(predsExcluded, predsIncluded)
pvals <- sapply(predsExcluded, function(x) as.numeric(extractp(x, fMaker(x, fitCurrent))))
pvals <- unlist(pvals)
toAdd <- pvals[which(pvals==min(pvals))]
if(length(toAdd)==0) return(fitCurrent)
if(toAdd <= aEnter) return(fMaker(names(toAdd), fitCurrent))
return(fitCurrent)
}
#' Removes a single predictor from a linear model based on its p-value
#'
#' This function will try and remove a single predictor from a current linear model.  A predictor will be removed if it has maximal p-value and its p-value is greater than a certain threshold.
#'
#' @param fitCurrent the current model of type "lm"
#' @param fullmodel a linear model containing all possible predictors.  Typically of the form lm(y~., data=data)
#' @param aRemove the threshold for removing the predictor, set to 0.1 by default
#' @return an updated linear model of type "lm"
stepbwd <- function(fitCurrent, fullmodel, aRemove = 0.1) {
predsIncluded <- rownames(anova(fitCurrent))
predsIncluded <- predsIncluded[predsIncluded != "Residuals"]
pvalues <- sapply(predsIncluded, function(x) as.numeric(extractp(x, fitCurrent)))
toRemove <- pvalues[which(pvalues == max(pvalues))]
if(toRemove > aRemove) return(fMaker(names(toRemove), fitCurrent, add=F))
return(fitCurrent)
}
#' Selects the best predictors for a linear model based on p-values
#'
#' This function will create a linear model based on the p-values for each predictor.  Selection can be done forwards from an empty model, backwards from a full model or stepwise which combines the two methods.
#' @param response the response variable of interest in the model
#' @param fullmodel a linear model containing all possible predictors.  Typically of the form lm(y~., data=data)
#' @param aEnter the threshold for adding new predictors, set to 0.1 by default
#' @param aRemove the threshold for removing predictors from the current model, set to 0.1 by default
#' @return a linear model of type
pStepwise <- function(response, fullmodel, aEnter = 0.1, aRemove = 0.1) {
continue <- TRUE
fitBwd <- lm(as.formula(paste(resp, "~1")))
while(continue){
print("Trying to add another predictor")
fitFwd = stepfwd(fitBwd, fullmodel)
print(fitFwd$call)
if(identical(fitFwd, fitBwd) == T) {
return(summary(fitFwd))
}else {
print("Trying to remove a predictor")
fitBwd = stepbwd(fitFwd, fullmodel)
}
}
}
pStepwise("rcc", fm)
f = pStepwise("rcc", fm)
class(f)
#' Easily access p-values from linear models
#'
#' This function gives the user easy access to p-values for specific predictors from a linear model
#'
#' @param pred the predictor from the linear model whose p-value is desired
#' @param fit a linear model of type "lm"
#' @return the p-value for the desired predictor from the linear model
#' @author Cory Langille <lang1729@gmail.com>
#' @seealso \code{lm}
#' @export
#'
extractp <- function(pred, fit) {
predClasses = attr(fit$terms, "dataClasses")        #finds the predictors that are categorical variables
fact = predClasses[names(predClasses) == pred]
if(fact == "factor") {
pvalues <- anova(fit)[,5]
predList <- rownames(anova(fit))
index <- which(predList == pred)
return(pvalues[index])
}else {
pvalues <- summary(fit)$coefficients[,4]
return(pvalues[names(pvalues)==pred])
}
}
#' Create formulas from strings to be used in linear models
#'
#' This function take a string and a linear model and either adds the predictor to the model, or removes it.
#'
#' @param pred the predictor to be added or removed from the current model
#' @param fitCurrent the current model to be updated
#' @param add by default adds the predictor to to the model.  add=F removes the predictor from the model
#' @return the updated model of type "lm"
#'
fMaker <- function(pred, fitCurrent, add=T) {
addNew <- as.formula(paste(".~.+", pred))
remNew <- as.formula(paste(".~.-", pred))
if(add) {
return(update(fitCurrent, addNew))
}  else {
return(update(fitCurrent, remNew))
}
}
#' Adds a single predictor to a linear model based on its p-value
#'
#' This function will try and add a new predictor to a current model.  A predictor will be added if it has minimum p-value among all predictors and its p-value is below a certain threshold
#'
#' @param fitCurrent the current model of type "lm"
#' @param fullmodel a linear model containing all possible predictors.  Typically of the form lm(y~., data=data)
#' @param aEnter the threshold for adding the predictor, set to 0.1 be default
#' @return an updated linear model of type "lm"
#'
stepfwd <- function(fitCurrent, fullmodel, aEnter = 0.1) {
predsIncluded <- rownames(anova(fitCurrent))
predsExcluded <- rownames(anova(fullmodel))
predsExcluded <- setdiff(predsExcluded, predsIncluded)
pvals <- sapply(predsExcluded, function(x) as.numeric(extractp(x, fMaker(x, fitCurrent))))
pvals <- unlist(pvals)
toAdd <- pvals[which(pvals==min(pvals))]
if(length(toAdd)==0) return(fitCurrent)
if(toAdd <= aEnter) return(fMaker(names(toAdd), fitCurrent))
return(fitCurrent)
}
#' Removes a single predictor from a linear model based on its p-value
#'
#' This function will try and remove a single predictor from a current linear model.  A predictor will be removed if it has maximal p-value and its p-value is greater than a certain threshold.
#'
#' @param fitCurrent the current model of type "lm"
#' @param fullmodel a linear model containing all possible predictors.  Typically of the form lm(y~., data=data)
#' @param aRemove the threshold for removing the predictor, set to 0.1 by default
#' @return an updated linear model of type "lm"
stepbwd <- function(fitCurrent, fullmodel, aRemove = 0.1) {
predsIncluded <- rownames(anova(fitCurrent))
predsIncluded <- predsIncluded[predsIncluded != "Residuals"]
pvalues <- sapply(predsIncluded, function(x) as.numeric(extractp(x, fitCurrent)))
toRemove <- pvalues[which(pvalues == max(pvalues))]
if(toRemove > aRemove) return(fMaker(names(toRemove), fitCurrent, add=F))
return(fitCurrent)
}
#' Selects the best predictors for a linear model based on p-values
#'
#' This function will create a linear model based on the p-values for each predictor.  Selection can be done forwards from an empty model, backwards from a full model or stepwise which combines the two methods.
#' @param response the response variable of interest in the model
#' @param fullmodel a linear model containing all possible predictors.  Typically of the form lm(y~., data=data)
#' @param aEnter the threshold for adding new predictors, set to 0.1 by default
#' @param aRemove the threshold for removing predictors from the current model, set to 0.1 by default
#' @return a linear model of type
pStepwise <- function(response, fullmodel, aEnter = 0.1, aRemove = 0.1) {
continue <- TRUE
fitBwd <- lm(as.formula(paste(resp, "~1")))
while(continue){
print("Trying to add another predictor")
fitFwd = stepfwd(fitBwd, fullmodel)
print(fitFwd$call)
if(identical(fitFwd, fitBwd) == T) {
return(fitFwd)
}else {
print("Trying to remove a predictor")
fitBwd = stepbwd(fitFwd, fullmodel)
}
}
}
f = pStepwise("rcc", fm)
f
summary(f)
library(pStepwise)
require(DAAG)
attach(ais)
resp= "rcc"
fm = lm(rcc~.,data=ais)
pStepwise(resp, fm)
require(roxygen2)
install.packages("roxygen2")
require(roxygen2)
library(pStepwise)
help(pStepwise)
rm(resp)
library(pStepwise)
help(subset)
help(extractp)
extractp
help(pStepwise)
require(pStepwise)
help(pStepwise)
help(extractp)
require(DAAG)
attach(ais)
names(ais)
for(i in names(ais)) print(class(i))
for(i in names(ais)) print(is.factor(i))
fm = lm(rcc~., data=ais)
fm$terms
extarctp("sport", fm)
extractp("sport", fm)
extractp("spor", fm)
library(pStepwise)
library(pStepwise)
pStepwise('rcc", fm')
pStepwise("rcc", fm')
)
''
pStepwise("rcc", fm)
attach(ais)
pStepwise("rcc", fm)
fm
resp = "rcc"
pStepwise(resp, fm)
pStepwise("rcc", lm(rcc~.,data=ais))
require(knitr)
mod
mod = lm(rcc~1, data=ais)
summary(mod)
plot(mod)
mod = lm(rcc~0, data=ais)
summary(mod)
mod = lm(rcc~1, data=ais)
summary(mod)
describe(rcc)
require(psych)
describe(rcc)
library(pStepwise)
getwd()
require(leaps)
setwd(dir = 'R/')
cement = read.table("cement.txt", header=TRUE)
setwd('/Users/Cory/Documents/R/')
cement = read.table("cement.txt", header=TRUE)
detach()
attach(cement)
cfm = lm(y~., data=cement)
r = regsubsets(cfm)
require(leaps)
r = regsubsets(cfm)
r = regsubsets(y~., data=cement)
r
summary(r)
plot(r, scale="bic")
pStepwise("y", lm(y~., data=cement))
resp = "y"
pStepwise(resp, cfm)
pStepwise("y", lm(y~., data=cement))
pStepwise(resp, lm(y~., data=cement))
pStepwise("y", lm(y~., data=cement))
library(pStepwise)
library(pStepwise)
require(pStepwise)
require(DAAG)
attach(ais)
fm = lm(rcc~., data=ais)
resp = "rcc"
pStepwise(resp,fm)
pStepwise
pStepwise <- function(response, fullmodel, method = "both", aEnter = 0.1, aRemove = 0.1) {
continue <- TRUE
fitFwd <- fullmodel                                         #creates the initial model for the 'back' method
fitBwd <- lm(as.formula(paste(response, "~1")))             #creates the initial model for 'forward'/'both' methods
while(continue){
if(method != 'back'){
fitFwd = stepfwd(fitBwd, fullmodel)                     #try to add a predictor
if(identical(fitFwd, fitBwd) == T) {                    #if no new predictors were added, it will stop
return(fitFwd)
}else if(method == 'both'){
fitBwd = stepbwd(fitFwd, fullmodel)                   #try to remove a predictor
}
} else if(method =='back'){
fitBwd <- stepbwd(fitFwd, fullmodel)
if(identical(fitFwd, fitBwd)==T) {
return(fitFwd)
} else {
fitFwd <- fitBwd
}
}
}
}
pStepwise(resp,fm)
pStepwise(resp,fm,method="forward")
pStepwise(resp,fm,method="both")
pStepwise(resp,fm,method="back")
fitBACK = pStepwise(resp,fm, method="back")
summary(fitBACK)
fitBOTH = pStepwise(resp,fm, method="both")
summary(fitBOTH)
fitFWD = pStepwise(resp,fm, method="forward")
pStepwise <- function(response, fullmodel, method = "both", aEnter = 0.1, aRemove = 0.1) {
continue <- TRUE
fitFwd <- fullmodel                                         #creates the initial model for the 'back' method
fitBwd <- lm(as.formula(paste(response, "~1")))             #creates the initial model for 'forward'/'both' methods
while(continue){
if(method != 'back'){
fitFwd = stepfwd(fitBwd, fullmodel)                     #try to add a predictor
if(identical(fitFwd, fitBwd) == T) {                    #if no new predictors were added, it will stop
return(fitFwd)
}else if(method == 'both'){
fitBwd = stepbwd(fitFwd, fullmodel)                   #try to remove a predictor
} else {
fitBwd <- fitFwd
}
} else if(method =='back'){
fitBwd <- stepbwd(fitFwd, fullmodel)
if(identical(fitFwd, fitBwd)==T) {
return(fitFwd)
} else {
fitFwd <- fitBwd
}
}
}
}
fitFWD = pStepwise(resp,fm, method="forward")
summary(fitFWD)
fitFWD = pStepwise(resp,fm, method="forward", aEnter=0.05)
summary(fitFWD)
fitFWD = pStepwise(resp,fm, method="both", aEnter=0.05)
summary(fitFWD)
fitFWD = pStepwise(resp,fm, method="both", aEnter=0.05, aRemove = 0.05)
summary(fitFWD)
fitFWD = pStepwise(resp,fm, method="both", aEnter=0.05, aRemove = 0.05)
summary(fitFWD)
fitFWD$model
fitFWD$call
summary(fitFWD)
fitFWD = pStepwise(resp,fm, method="both", aEnter=0.05, aRemove = 0.04)
summary(fitFWD)
pStepwise <- function(response, fullmodel, method = "both", aEnter = 0.1, aRemove = 0.1) {
continue <- TRUE
fitFwd <- fullmodel                                             #creates the initial model for the 'back' method
fitBwd <- lm(as.formula(paste(response, "~1")))                 #creates the initial model for 'forward'/'both' methods
while(continue){
if(method != 'back'){
fitFwd <- stepfwd(fitBwd, fullmodel, aEnter = aEnter)       #try to add a predictor
if(identical(fitFwd, fitBwd) == T) {                        #if no new predictors were added, it will stop
return(fitFwd)
}else if(method == 'both'){
fitBwd = stepbwd(fitFwd, fullmodel, aRemove = aRemove)    #try to remove a predictor
} else {
fitBwd <- fitFwd
}
} else if(method =='back'){
fitBwd <- stepbwd(fitFwd, fullmodel, aRemove = aRemove)
if(identical(fitFwd, fitBwd)==T) {
return(fitFwd)
} else {
fitFwd <- fitBwd
}
}
}
}
fitFWD = pStepwise(resp,fm, method="both", aEnter=0.05, aRemove = 0.04)
summary(fitFWD)
fitFWD = pStepwise(resp,fm, method="both", aEnter=0.05, aRemove = 0.05)
summary(fitFWD)
fitFWD = pStepwise(resp,fm, method="both", aEnter=0.05, aRemove = 0.06)
summary(fitFWD)
fitFWD = pStepwise(resp,fm, method="both", aEnter=0.1, aRemove = 0.06)
summary(fitFWD)
library(pStepwise)
setwd('R/')
ls()
setwd("/Users/Cory/Documents/R/")
cement = read.csv('cement.txt', header=T)
names(cement)
cement
attach(cement)
y
cement = read.csv('cement.txt')
attach(cement)
y
cement
cement = read.csv('cement.csv')
cement = read.table('cement.txt', header=T)
cement
attach(cement)
resp = "y"
fm = lm(y~., data=cement)
pStepwise(resp,fm)
pStepwise(resp,fm, method='forward')
pStepwise(resp,fm, method='back')
